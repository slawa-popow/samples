<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Rubik:wght@300;400&family=Tiro+Gurmukhi&display=swap" rel="stylesheet">

    <title>Document</title>
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/npm/brython@3.10.6/brython.min.js"
    ></script>
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/npm/brython@3.10.6/brython_stdlib.js"
    ></script>

    <style>
        html {
            font-family: 'Rubik', sans-serif;
            font-size: 0.9em;
        }
        .lcontent {
            margin: 20px 0;
            padding: 0 20px;
            width: 500px;
            height: 400px;
            border: 1px solid rgba(72, 114, 230, 0.493);
            float: left;
        }
        .cntcontent {
            width: 20px;            
            float: left;
            margin: 20px 20px;
        }
        .rcontent {
            margin: 20px 0;
            padding: 20 20px;
            width: 500px;
            height: 400px;
            border: 1px solid rgba(72, 114, 230, 0.493);
            float: left; 
            
        }
        .bcontent {
            clear: both;
            width: 97%;
            padding: 20px 20px;
            border: 1px solid rgba(52, 216, 65, 0.493);
        }
        table {
            width: 100%;
        }
        table td {
            width: 50%;
            padding: 5px 0;
        }
        .label {
            display: block;
            text-align: center;
            padding: 5px 0;
            margin: 5px 0;
            margin-bottom: 5px;
            background-color: rgba(26, 95, 175, 0.925);
            color: rgb(255, 254, 254);
        }
        .info {
            display: block;
            text-align: center;
            padding: 5px 0;
            margin: 5px 0;
            margin-bottom: 5px;
            background-color: rgba(26, 175, 143, 0.555);
            color: black;
            font-size: 1.1em;
            font-weight: bold;
        }
        #start-heat{
            box-shadow:inset 0px 1px 0px 0px #9acc85;
            background:linear-gradient(to bottom, #74ad5a 5%, #68a54b 100%);
            background-color:#74ad5a;
            border-radius: 5px;
            border:1px solid #3b6e22;
            display:inline-block;
            cursor:pointer;
            color:#ffffff;
            padding:10px 16px;
            font-size: 1em;
            text-decoration:none;
        }
        #start-heat:hover {
            background:linear-gradient(to bottom, #68a54b 5%, #74ad5a 100%);
            background-color:#68a54b;
        }
        #start-heat:active {
            position:relative;
            top:1px;
        }
        #stop-heat {
            box-shadow:inset 0px 1px 0px 0px #cf866c;
            background:linear-gradient(to bottom, #d0451b 5%, #bc3315 100%);
            background-color:#d0451b;
            border-radius:5px;
            border:1px solid #942911;
            display:inline-block;
            cursor:pointer;
            color:#ffffff;
            font-size: 1em;
            padding:10px 16px;
            text-decoration:none;
            text-shadow:0px 1px 0px #854629;
        }
        #stop-heat:hover {
            background:linear-gradient(to bottom, #bc3315 5%, #d0451b 100%);
            background-color:#bc3315;
        }
        #stop-heat:active {
            position:relative;
            top:1px;
        }
        button {
            box-shadow:inset 0px 1px 0px 0px #a6827e;
            background:linear-gradient(to bottom, #7d5d3b 5%, #634b30 100%);
            background-color:#7d5d3b;
            border-radius:5px;
            border:1px solid #54381e;
            display:inline-block;
            cursor:pointer;
            color:#ffffff;
            font-size:1em;
            padding:10px 16px;
            text-decoration:none;
        }
        button:hover {
            background:linear-gradient(to bottom, #634b30 5%, #7d5d3b 100%);
            background-color:#634b30;
        }
        button:active {
            position:relative;
            top:1px;
        }
        input {
            height: 28px;
            font-size: 1.1em;
        }


    </style>
  </head>


<body onload="brython(1)">
<div class="lcontent">
    <svg width="550" height="450" viewBox="0 0 250 150" xmlns="http://www.w3.org/2000/svg" xmlns:bx="https://boxy-svg.com">
        <defs></defs>
        <g id="termostat-1">
          <path style="fill: rgb(216, 216, 216); stroke: rgba(0, 0, 0, 0.56);" d="M 22 38 H 37 V 133 A 5 5 0 0 1 32 138 H 27 A 5 5 0 0 1 22 133 V 38 Z" id="tube-1" bx:shape="rect 22 38 15 100 0 0 5 5 1@8a75a968"></path>
          <rect x="27" y="13" width="4.488" height="25" style="stroke-width: 0px; stroke: rgb(9, 9, 9); fill: rgba(61, 61, 61, 0.96);" bx:origin="0.5 0.48059"></rect>
          <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 7px; white-space: pre;" x="51.156" y="41.925" id="termo1">термопара #1<tspan x="51.15599822998047" dy="1em">​</tspan></text>
          <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 7px; white-space: pre;" x="51.156" y="55.375" id="value-temp1">t = 10 </text>
        </g>
        <g id="termostat-2">
          <path style="fill: rgb(216, 216, 216); stroke: rgba(0, 0, 0, 0.56);" d="M 119.61 37.616 H 134.61 V 132.616 A 5 5 0 0 1 129.61 137.616 H 124.61 A 5 5 0 0 1 119.61 132.616 V 37.616 Z" id="tube-2" bx:shape="rect 119.61 37.616 15 100 0 0 5 5 1@5d70c48e"></path>
          <rect x="124.61" y="12.616" width="4.488" height="25" style="stroke-width: 0px; stroke: rgb(9, 9, 9); fill: rgba(61, 61, 61, 0.96);" bx:origin="0.5 0.48059"></rect>
          <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 7px; white-space: pre;" x="51.156" y="41.925" id="termo2" transform="matrix(1, 0, 0, 1, 97.610428, -0.384293)">термопара #2<tspan x="51.15599822998047" dy="1em">​</tspan></text>
          <text style="fill: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 7px; white-space: pre;" x="148.766" y="54.991" id="value-temp2">t = 10 </text>
        </g>
      </svg>
</div>
<div class="cntcontent"></div>

<div class="rcontent">
<span class="label">Линейный нагрев</span>
<table>
    
    <tr>
        <td>
            <button id="start-heat">включить нагрев</button>
        </td>
        <td>
            <button id="stop-heat">стоп нагрев</button>
        </td>
    </tr>
    <tr>
        <td colspan="2"><span class="info">стоп</span></td>
    </tr>
    <tr>
        <td colspan="2"><span class="label">время нагрева термопар</span></td>
    </tr>
    <tr>
        <td>
            <button id="set-temp-sensor1">#1 нагреть до:</button>
        </td>
        <td>
            <input id="value-temp-sensor1" type="text" size="10" value="65">
        </td>
    </tr>
    <tr>
        <td>
            <button id="set-temp-sensor2">#2 нагреть до:</button>
        </td>
        <td>
            <input id="value-temp-sensor2" type="text" size="10" value="172">
        </td>
    </tr>
    <tr>
        <td><button id="set-time-heat">время нагрева сек.:</button></td>
        <td><input id="value-time-heat" type="text" size="10" value="10"></td>
    </tr>
    <tr>
        <td colspan="2"><span class="info">--</span></td>
    </tr>
</table>
</div>
<div class="bcontent"></div>
<script type="text/python">
    from browser import document, window, html, bind
    from typing import Generator, Coroutine, Any
    from collections import deque
    


    # айди svg: g#1 - "termostat-1"; корпус термопары #1 - "tube-1"; 
    #              текст номер термопары - "termo1"; текст текущ. температура - "value-temp1" ;
    # айди svg: g#2 - "termostat-2"; корпус термопары #2 - "tube-2";
    #              текст номер термопары - "termo2";  текст текущ. температура - "value-temp2";
    #
    # айди кнопок: #start-heat - включить нагрев; #stop-heat - стоп нагрев; 
    #               #set-temp-sensor1 - нагреть тепмопару #1 до температуры;
    #               #set-temp-sensor2 - нагреть тепмопару #2 до температуры;
    #               #set-time-heat - время нагрева термопар до 300 градусов (макс.);
    #
    # айди полей ввода: #value-temp-sensor1 - макс. нагрев термопары #1;
    #                   #value-temp-sensor2 - макс. нагрев термопары #2;
    #                   #value-time-heat - ввод времени нагрева термопар;



    class Termostat:
        """Класс svg группы термопары"""

        __slots__: tuple = ("_id_g", "_fill", "_cold_fill", "_heat_fill", "_svg_g_obj", "_max_temp", "evnt", 
                            "_current_temp", "_name_text", "_value_text", "_svg_fill_obj", "info", "_id_fill",
                            "evnt_name",
                        )
        # объект span class ".info" вывод сообщений
        label_info = document.querySelector(".info")

        def __init__(self, id_svg: tuple) -> None:
            self._id_g, self._id_fill = id_svg

            # объекты svg группы и корпуса термопары
            self._svg_g_obj = document[self._id_g]
            self._svg_fill_obj = document[self._id_fill]

            # объект <span> .info
            self.info = self.__class__.label_info

            # цвет холодной термопары. цвет беру прямо из объектa
            self._cold_fill: tuple = (216, 216, 216)

            # текущий изменяющийся цвет корпуса. сначала равен холодному (серый)
            self._fill = self._cold_fill

            # явно цвет горячей термопары. из серого в красный делаем уменьшением до нуля 2 и 3 числа
            # например: rgb(216, 0, 0) - красный. rgb(216, 216, 216) - серый
            self._heat_fill: tuple = (216, 0, 0)

            # температура при которой сработает выходное реле. Равно нан пока.
            self._max_temp = 200

            # текущая температура
            self._current_temp = 20

            # текст имя термопары #n. объект. первый из списка дочерних текстовых элементов. для доступа к самому тексту: self._name_text.text 
            self._name_text = self._svg_g_obj.select("text")[0]

            # текст текущее значение температуры
            self._value_text = self._svg_g_obj.select("text")[1]

            #имя события
            self.evnt_name: str = "yes_" + self.get_id()
            
            #событие
            self.evnt = window.Event.new(self.evnt_name)

            


        @classmethod
        def valid_value(cls, value: Any) -> float:
            result = 0.0
            try:
                result = float(value)
                cls.label_info.innerHTML = "-..-"
            except ValueError:
                cls.label_info.innerHTML = "введено не числовое значение."                
            finally:
                return result

        @property
        def max_temp(self) -> int:
            """температура до которой нагревать термопару"""
            return self._max_temp

        @max_temp.setter
        def max_temp(self, value: Any) -> None:
            self._max_temp = self.valid_value(value)

        @property
        def color(self) -> str:
            """цвет копуса термопары"""
            clr = self._svg_fill_obj.style["fill"].lstrip("rgb(").rstrip(")").split(", ")
            return tuple(int(i) for i in clr)


        @color.setter
        def color (self, value: tuple) -> None:
            """установить цвет термопаты. принимает кортеж rgb чисел."""

            r, g, b = (self.valid_value(i) for i in value)
            self._svg_fill_obj.style["fill"] = f"rgb({int(r)}, {int(g)}, {int(b)})"
    


        @property
        def temp(self) -> str:
            """текущая температура"""

            return self._current_temp


        @temp.setter
        def temp(self, value: int) -> None:
            # записать в текст svg и в атрибут текущую температуру 
            self._value_text.text = f"t = {str(value)}"
            self._current_temp = value


        def cold_color(self) -> tuple:
            """ вернуть холодный цвет"""
            return self._cold_fill

        def get_id(self) -> str:
            """вернуть айди как строку"""
            return self._id_g


        def do_event(self, e) -> None:
            """что произойдет при возникновении события"""

            # покрасить текст svg зеленым
            self._value_text.style["fill"] = "green"
            # self.temp = 1.0



        def __call__(self) -> Coroutine:
            """вызываемый объект - генераторный метод. """
            # начало сопрограммы. 
            # этот йилд дергаем при инициации объекта-сопрограммы первый раз ( send(None) or next(obj) )
            yield
               
            # это портал с вызывающей стороной. между этим объектом и вызывающей стороной
            # блокирован метод делегирующего генератора
            # мы в нашем случае только получаем, отдаем Нан.
            temp = yield

            # получили значение [self.step объекта класса Inspect из метода inspect() в строчке с send]
            # просто записываем значение в атрибут текущей температуры и постепенно перекрашиваем корпус термопар в красный
            self.temp += temp
            step = temp * 0.01
            r, g, b = self.color
            g -= step
            b -= step
            self.color = (r, g, b)

            # если корпус ваще нагрелся до красна то останавливаем перекрашивание в красный
            if (g < 1) and (b < 1):
                step = 0

            # если в сумме текущее значение температуры больше
            # занесенного нами из поля ввода, то возвращаем не Нан, а объект события 
            return self.evnt if self.temp >= self.max_temp else None
                


            
    
    # ----------------------------------------------------------------------------------------

    class Grouper:
        """ Класс делегирующего генератора"""            

        def __init__(self, *args) -> None:
            self._gens: tuple = tuple(args)
            
            # регестрируем имя события и метод его обработки 
            # имя события см. атрибут evnt_name, в том же классе Termostat и соотв. метод
            # Конечно лучше все-таки сделать через интерфейс. Ввиду того что этот код чисто для эксперементов с сознанием,
            # то пока так.
            for obj in self._gens:
                document.addEventListener(obj.evnt_name, obj.do_event)

        
        def null_states_obj(self) -> None:
            for obj in self._gens:
                obj.temp = 10
                obj.color = obj.cold_color()

            
        def group(self) -> Coroutine:

            # временный список из которого будем удалять объекты после их отработки
            self.sub_gens: list = list(self._gens)

            while True:
                gens: list = list(self.sub_gens)
                
                for coro in gens:

                    # при каждой итерации цикла устанавливаем канал между
                    # coro (вызываемый обЪект-генератораная ф-ция (метод)) и 
                    # вызывающей стороной (строчка с send в inspect())
                    event_coro = yield from coro()

                    if event_coro:

                        # если вернулось не Нан, то это заряженный объект события
                        # стреляем зарегестрированным событием (говорим менеджеру по событиям, что произошло событие)
                        document.dispatchEvent(event_coro)

                        # удаляем объект субгенератора из списка (т-к он отработал отчитавшись объектом события)
                        self.sub_gens.remove(coro)

                    
                    if len(self.sub_gens) == 0:

                        # если список ваще пуст, то вызываем исключение и идем обратно в зад (в вызывающую сторону)
                        # где и обрабатываем это исключение. 
                        raise GeneratorExit("Grouper 'GeneratorExit' group.close()")


    # ----------------------------------------------------------------------------------------------

    class Inspector:

        def __init__(self, grouper: Grouper) -> None:
            self.sub_gen = grouper
            self.grouper = None
            self.step: float = 1.0
            self.init()
        
        def init(self) -> None:
            
            self.grouper = self.sub_gen.group()           
            next(self.grouper) 
           


        def inspect(self) -> None:
            """первым выполнится после нажатия кнопки [включить нагрев].
               Инициализация генераторной функции делегирующего генератора.
               Открытие канала с субгенераторами. Если в делегирующем генераторе
               закончились объекты (в списке) для работы, то он вызывает исключение 
               GeneratorExit, здесь его обрабатываем. Этот метод ставится в event loop макрозадач браузера
               посредством вызова  window.setTimeout(self.inspect) с нулевой задержкой."""

            try:
                next(self.grouper)
            except StopIteration:

                # выбросится StopIteration если повторно нажать [включить нагрев]
                # обрабатываем путем повторной инициализации генераторной ф-ции (метода)
                self.init()

            try:
                # открывается канал с субгенераторами, отправляется каждому значение step
                self.grouper.send(self.step) 
                             
                window.setTimeout(self.inspect)
               
            except GeneratorExit as ge:

                # вызов метода после отработки делегирующего генератора, он бросит исключение 
                self.sub_gen.null_states_obj()
                print(ge)
    
                
    # -----------------------------------------------------------------------------------------------


    sensor1 = Termostat(("termostat-1", "tube-1"))
    sensor2 = Termostat(("termostat-2", "tube-2"))
    

    # нагреть до #1
    @bind(document["set-temp-sensor1"], "click")
    def heat1_to(e):
        sensor1.max_temp = document["value-temp-sensor1"].value
         
    
    # нагреть до #2
    @bind(document["set-temp-sensor2"], "click")
    def heat2_to(e):
        sensor2.max_temp = document["value-temp-sensor2"].value


    # в этом обработчике зеленой кнопки создаем объекты делегирующего и обработчика субгенераторов
    # иначе при повторном нажатии после первого раза пришлось бы что-то лепить для пересоздания этих объектов
    # т-к итераторы не вечные. Как презервативы - одноразовые

    @bind(document["start-heat"], "click")
    def begin_heat(e):
        grp = Grouper(sensor1, sensor2)
        inspector = Inspector(grp)
        inspector.inspect()



    # -------------------------------------------------------------------------------------------------

    """
    animation = None

    # создание пользовательского события по достижении темперетуры
    temp_event = window.Event.new("ok_temp")

    def chcolor(trm, step):
        r = 216
        g = 216
        b = 216
        t = 0
        global animation
        def animate(tm):
            global animation, temp_event
            nonlocal r, g, b, t, step
            animation = window.requestAnimationFrame(animate)
            trm.temp = int(t*1.5)
            g -= step
            b -= step
            t += step

            # вызвать событие по достижении более 120 градусов
            if (t*1.5) >= 120:
                document.dispatchEvent(temp_event)

            trm.color = (r, g, b)
            if (g < 1) and (b < 1):
                step = 0
                window.cancelAnimationFrame(animation)
                trm.color = trm.cold_color()
                trm.temp = 0
                animation = None
        animate(1)
        


    @bind(document["start-heat"], "click")
    def newfill(e):
        global animation
        if animation is None:
            chcolor(trm, 0.5)

    @bind(document["stop-heat"], "click")
    def oldfill(e):
        global animation
        window.cancelAnimationFrame(animation)
        trm.color = trm.cold_color()
        
        animation = None

    # обработчик события по достижении 120 градусов
    def okay(e):
        trm.temp = "событие"

    # следить за событием "ok_temp"
    document.addEventListener("ok_temp", okay)
    """



</script>

</body>
</html>
